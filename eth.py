# eth_bot_super_analyst.py - Bot ETH v·ªõi 10 t√≠nh nƒÉng ph√¢n t√≠ch n√¢ng cao

import requests
import time
import schedule
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from io import BytesIO
import logging
import os
import sys
from collections import deque
import ta  # Th∆∞ vi·ªán ph√¢n t√≠ch k·ªπ thu·∫≠t n√¢ng cao

# Fix Unicode encoding for Windows console
if sys.platform == "win32":
    import codecs
    sys.stdout = codecs.getwriter("utf-8")(sys.stdout.detach())
    sys.stderr = codecs.getwriter("utf-8")(sys.stderr.detach())

# ================== üîê C·∫§U H√åNH ==================
BOT_TOKEN = os.getenv("BOT_TOKEN", "7621331832:AAEAdFhGCHvqggE8ZwgpxoSPZZ729MDV-UA")
CHAT_ID = os.getenv("CHAT_ID", "5752214928")

# üåê URLs
TELEGRAM_API = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
TELEGRAM_PHOTO = f"https://api.telegram.org/bot{BOT_TOKEN}/sendPhoto"
BINANCE_KLINES = "https://api.binance.com/api/v3/klines"
BINANCE_FUNDING = "https://fapi.binance.com/fapi/v1/fundingRate"
BINANCE_ORDERBOOK = "https://fapi.binance.com/fapi/v1/depth"
BINANCE_WALLET = "https://api.binance.com/sapi/v1/accountSnapshot" # V√≠ d·ª•, c·∫ßn API key

# üìä L∆∞u tr·ªØ t√≠n hi·ªáu ƒë·ªÉ backtest & th·ªëng k√™
signal_history = deque(maxlen=100)
performance_stats = {
    'total_signals': 0,
    'win_signals': 0,
    'total_pnl': 0.0
}

# ==================== üîß C·∫§U H√åNH LOGGING ====================
def setup_logging():
    """Setup logging v·ªõi UTF-8 encoding"""
    for handler in logging.root.handlers[:]:
        logging.root.removeHandler(handler)
    
    file_handler = logging.FileHandler("ethbot_super.log", encoding='utf-8')
    console_handler = logging.StreamHandler(sys.stdout)
    
    formatter = logging.Formatter(
        '%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger

logger = setup_logging()

def safe_log(message, level="info"):
    """H√†m log an to√†n v·ªõi Unicode"""
    try:
        if level == "info":
            logger.info(message)
        elif level == "error":
            logger.error(message)
        elif level == "warning":
            logger.warning(message)
    except UnicodeEncodeError:
        clean_message = message.encode('ascii', 'ignore').decode('ascii')
        if level == "info":
            logger.info(f"[CLEANED] {clean_message}")
        elif level == "error":
            logger.error(f"[CLEANED] {clean_message}")
        elif level == "warning":
            logger.warning(f"[CLEANED] {clean_message}")
            # ==================== üîß H√ÄM H·ªñ TR·ª¢ C∆† B·∫¢N ====================

def send_telegram_message(text: str):
    """G·ª≠i tin nh·∫Øn qua Telegram v·ªõi retry"""
    max_retries = 3
    for attempt in range(max_retries):
        try:
            response = requests.post(TELEGRAM_API, data={
                "chat_id": CHAT_ID,
                "text": text,
                "parse_mode": "Markdown"
            }, timeout=15)
            
            if response.status_code == 200:
                safe_log("‚úÖ Tin nh·∫Øn ƒë√£ g·ª≠i!")
                return True
            else:
                safe_log(f"‚ùå G·ª≠i tin nh·∫Øn th·∫•t b·∫°i: {response.status_code} - {response.text}", "error")
                
        except Exception as e:
            safe_log(f"‚ùå L·ªói g·ª≠i tin nh·∫Øn (l·∫ßn {attempt + 1}): {e}", "error")
            
        time.sleep(2)
    
    return False

def send_telegram_photo(photo_buffer: BytesIO, caption: str = ""):
    """G·ª≠i ·∫£nh qua Telegram"""
    try:
        response = requests.post(TELEGRAM_PHOTO, data={
            "chat_id": CHAT_ID,
            "caption": caption
        }, files={"photo": photo_buffer}, timeout=20)
        if response.status_code == 200:
            safe_log("‚úÖ ·∫¢nh ƒë√£ g·ª≠i!")
            return True
        else:
            safe_log(f"‚ùå G·ª≠i ·∫£nh th·∫•t b·∫°i: {response.status_code} - {response.text}", "error")
            return False
    except Exception as e:
        safe_log(f"‚ùå L·ªói g·ª≠i ·∫£nh: {e}", "error")
        return False

def test_telegram_connection():
    """Test k·∫øt n·ªëi Telegram"""
    safe_log("üîç ƒêang test k·∫øt n·ªëi Telegram...")
    try:
        response = requests.post(TELEGRAM_API, data={
            "chat_id": CHAT_ID,
            "text": "ü§ñ Bot ETH Test - K·∫øt n·ªëi th√†nh c√¥ng!"
        }, timeout=10)
        if response.status_code == 200:
            safe_log("‚úÖ K·∫øt n·ªëi Telegram OK!")
            return True
        else:
            safe_log(f"‚ùå L·ªói Telegram: {response.status_code} - {response.text}", "error")
            return False
    except Exception as e:
        safe_log(f"‚ùå L·ªói k·∫øt n·ªëi: {e}", "error")
        return False

def get_klines(symbol="ETHUSDT", interval="15m", limit=300):
    """L·∫•y d·ªØ li·ªáu n·∫øn t·ª´ Binance"""
    try:
        response = requests.get(BINANCE_KLINES, params={
            "symbol": symbol,
            "interval": interval,
            "limit": limit
        }, timeout=10)
        if response.status_code != 200:
            safe_log(f"‚ùå L·ªói Binance: {response.status_code}")
            return None
        data = response.json()
        df = pd.DataFrame(data, columns=[
            "open_time", "open", "high", "low", "close", "volume",
            "close_time", "quote_asset_volume", "number_of_trades",
            "taker_buy_base", "taker_buy_quote", "ignore"
        ])
        df["close"] = pd.to_numeric(df["close"])
        df["high"] = pd.to_numeric(df["high"])
        df["low"] = pd.to_numeric(df["low"])
        df["open"] = pd.to_numeric(df["open"])
        df["volume"] = pd.to_numeric(df["volume"])
        df["open_time"] = pd.to_datetime(df["open_time"], unit='ms')
        return df
    except Exception as e:
        safe_log(f"‚ùå L·ªói k·∫øt n·ªëi Binance: {e}")
        return None
    # ==================== üîß PH√ÇN T√çCH K·ª∏ THU·∫¨T N√ÇNG CAO ====================

def compute_rsi(series, window=14):
    delta = series.diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    avg_gain = gain.rolling(window).mean()
    avg_loss = loss.rolling(window).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def compute_macd(series, fast=12, slow=26, signal=9):
    ema_fast = series.ewm(span=fast).mean()
    ema_slow = series.ewm(span=slow).mean()
    macd = ema_fast - ema_slow
    macd_signal = macd.ewm(span=signal).mean()
    return macd, macd_signal

def compute_bollinger_bands(series, window=20, num_std=2):
    ma = series.rolling(window).mean()
    std = series.rolling(window).std()
    upper = ma + (std * num_std)
    lower = ma - (std * num_std)
    return ma, upper, lower

def compute_atr(high, low, close, window=14):
    """T√≠nh Average True Range"""
    tr0 = abs(high - low)
    tr1 = abs(high - close.shift())
    tr2 = abs(low - close.shift())
    tr = pd.DataFrame({'tr0': tr0, 'tr1': tr1, 'tr2': tr2}).max(axis=1)
    atr = tr.rolling(window).mean()
    return atr

def detect_candlestick_patterns(df):
    """Ph√°t hi·ªán m√¥ h√¨nh n·∫øn Nh·∫≠t (Hammer, Engulfing, Doji, v.v.)"""
    signals = []
    
    # Hammer & Inverted Hammer
    body = abs(df['close'] - df['open'])
    lower_wick = np.where(df['close'] > df['open'], 
                         df['open'] - df['low'], 
                         df['close'] - df['low'])
    upper_wick = np.where(df['close'] > df['open'], 
                         df['high'] - df['close'], 
                         df['high'] - df['open'])
    
    # Hammer: body nh·ªè, ch√¢n d∆∞·ªõi d√†i
    hammer = (body < (df['high'] - df['low']) * 0.3) & (lower_wick > body * 2)
    if hammer.iloc[-1]:
        signals.append("üî® M√¥ h√¨nh Hammer")
    
    # Shooting Star: body nh·ªè, ch√¢n tr√™n d√†i
    shooting_star = (body < (df['high'] - df['low']) * 0.3) & (upper_wick > body * 2)
    if shooting_star.iloc[-1]:
        signals.append("‚≠ê M√¥ h√¨nh Shooting Star")
    
    # Engulfing Bullish
    prev_body = df['close'].shift() - df['open'].shift()
    curr_body = df['close'] - df['open']
    engulfing_bull = (prev_body < 0) & (curr_body > 0) & (df['close'] > df['open'].shift()) & (df['open'] < df['close'].shift())
    if engulfing_bull.iloc[-1]:
        signals.append("üü¢ M√¥ h√¨nh Bullish Engulfing")
    
    # Engulfing Bearish
    engulfing_bear = (prev_body > 0) & (curr_body < 0) & (df['close'] < df['open'].shift()) & (df['open'] > df['close'].shift())
    if engulfing_bear.iloc[-1]:
        signals.append("üî¥ M√¥ h√¨nh Bearish Engulfing")
    
    # Doji
    doji = abs(df['close'] - df['open']) < (df['high'] - df['low']) * 0.1
    if doji.iloc[-1]:
        signals.append("‚ö™ M√¥ h√¨nh Doji")
    
    return signals

def detect_supply_demand_zones(df, lookback=50):
    """Ph√°t hi·ªán v√πng Supply/Demand Zone"""
    zones = []
    df_recent = df.tail(lookback)
    
    # Demand Zone: Gi√° gi·∫£m m·∫°nh r·ªìi b·∫≠t l√™n
    for i in range(2, len(df_recent)-2):
        if (df_recent.iloc[i-1]['close'] > df_recent.iloc[i]['close'] and 
            df_recent.iloc[i]['close'] < df_recent.iloc[i+1]['close'] and
            df_recent.iloc[i+1]['close'] < df_recent.iloc[i+2]['close']):
            zone_price = df_recent.iloc[i]['low']
            zones.append(f"üü¢ Demand Zone t·∫°i ${zone_price:.2f}")
    
    # Supply Zone: Gi√° tƒÉng m·∫°nh r·ªìi gi·∫£m xu·ªëng
    for i in range(2, len(df_recent)-2):
        if (df_recent.iloc[i-1]['close'] < df_recent.iloc[i]['close'] and 
            df_recent.iloc[i]['close'] > df_recent.iloc[i+1]['close'] and
            df_recent.iloc[i+1]['close'] > df_recent.iloc[i+2]['close']):
            zone_price = df_recent.iloc[i]['high']
            zones.append(f"üî¥ Supply Zone t·∫°i ${zone_price:.2f}")
    
    return zones[:3]  # Tr·∫£ v·ªÅ 3 v√πng g·∫ßn nh·∫•t

def market_phase_analysis(df):
    """Ph√¢n t√≠ch giai ƒëo·∫°n th·ªã tr∆∞·ªùng (Accumulation, Markup, Distribution, Markdown)"""
    df['sma20'] = df['close'].rolling(20).mean()
    df['sma50'] = df['close'].rolling(50).mean()
    
    current = df.iloc[-1]
    prev = df.iloc[-2]
    
    # ƒê∆°n gi·∫£n h√≥a: d·ª±a tr√™n xu h∆∞·ªõng SMA v√† RSI
    if current['sma20'] > current['sma50'] and current['rsi'] < 70:
        return "üìà Giai ƒëo·∫°n MARKUP (TƒÉng gi√°)"
    elif current['sma20'] < current['sma50'] and current['rsi'] > 30:
        return "üìâ Giai ƒëo·∫°n MARKDOWN (Gi·∫£m gi√°)"
    elif current['sma20'] > current['sma50'] and current['rsi'] > 70:
        return "üìä Giai ƒëo·∫°n DISTRIBUTION (Ph√¢n ph·ªëi)"
    elif current['sma20'] < current['sma50'] and current['rsi'] < 30:
        return "üè¶ Giai ƒëo·∫°n ACCUMULATION (T√≠ch l≈©y)"
    else:
        return "üîÑ Giai ƒëo·∫°n SIDEWAYS (ƒêi ngang)"

def detect_fake_breakout(df):
    """Ph√°t hi·ªán t√≠n hi·ªáu gi·∫£ (Fake Breakout)"""
    if len(df) < 3:
        return False
    
    current = df.iloc[-1]
    prev = df.iloc[-2]
    
    # N·∫øu volume tƒÉng m·∫°nh nh∆∞ng gi√° kh√¥ng ƒëi ti·∫øp
    volume_spike = current['volume'] > df['volume'].tail(10).mean() * 2
    price_weak = abs((current['close'] - prev['close']) / prev['close']) < 0.005  # < 0.5%
    
    if volume_spike and price_weak:
        return True
    return False
# ==================== üîß PH√ÇN T√çCH N√ÇNG CAO (BINANCE FUTURES) ====================

def get_funding_rate(symbol="ETHUSDT"):
    """L·∫•y Funding Rate t·ª´ Binance Futures"""
    try:
        response = requests.get(BINANCE_FUNDING, params={
            "symbol": symbol,
            "limit": 1
        }, timeout=10)
        if response.status_code == 200:
            data = response.json()
            if data:
                rate = float(data[0]['fundingRate']) * 100
                return rate
        return 0
    except Exception as e:
        safe_log(f"‚ùå L·ªói l·∫•y Funding Rate: {e}")
        return 0

def get_orderbook(symbol="ETHUSDT", limit=50):
    """L·∫•y Order Book t·ª´ Binance Futures"""
    try:
        response = requests.get(BINANCE_ORDERBOOK, params={
            "symbol": symbol,
            "limit": limit
        }, timeout=10)
        if response.status_code == 200:
            data = response.json()
            bids = pd.DataFrame(data['bids'], columns=['price', 'qty'])
            asks = pd.DataFrame(data['asks'], columns=['price', 'qty'])
            bids['price'] = pd.to_numeric(bids['price'])
            bids['qty'] = pd.to_numeric(bids['qty'])
            asks['price'] = pd.to_numeric(asks['price'])
            asks['qty'] = pd.to_numeric(asks['qty'])
            return bids, asks
        return None, None
    except Exception as e:
        safe_log(f"‚ùå L·ªói l·∫•y Order Book: {e}")
        return None, None

def analyze_orderbook(bids, asks, current_price):
    """Ph√¢n t√≠ch Order Book ƒë·ªÉ t√¨m b·ª©c t∆∞·ªùng bid/ask"""
    signals = []
    if bids is None or asks is None:
        return signals
    
    # T√¨m b·ª©c t∆∞·ªùng bid (mua l·ªõn)
    bid_wall = bids[bids['qty'] > bids['qty'].quantile(0.95)]
    if not bid_wall.empty:
        wall_price = bid_wall.iloc[0]['price']
        if abs(wall_price - current_price) / current_price < 0.01:  # Trong 1%
            signals.append(f"üü¢ B·ª©c t∆∞·ªùng BID t·∫°i ${wall_price:.2f}")
    
    # T√¨m b·ª©c t∆∞·ªùng ask (b√°n l·ªõn)
    ask_wall = asks[asks['qty'] > asks['qty'].quantile(0.95)]
    if not ask_wall.empty:
        wall_price = ask_wall.iloc[0]['price']
        if abs(wall_price - current_price) / current_price < 0.01:  # Trong 1%
            signals.append(f"üî¥ B·ª©c t∆∞·ªùng ASK t·∫°i ${wall_price:.2f}")
    
    return signals
# ==================== üîß SO S√ÅNH V√Ä B√ÅO C√ÅO ====================

def compare_with_altcoins():
    """So s√°nh ETH v·ªõi c√°c altcoin kh√°c"""
    altcoins = ["BTCUSDT", "SOLUSDT", "AVAXUSDT", "LINKUSDT"]
    eth_change = 0
    avg_alt_change = 0
    
    try:
        df_eth = get_klines("ETHUSDT", "1h", 25)
        if df_eth is not None:
            eth_change = ((df_eth.iloc[-1]['close'] - df_eth.iloc[0]['close']) / df_eth.iloc[0]['close']) * 100
        
        changes = []
        for alt in altcoins:
            df_alt = get_klines(alt, "1h", 25)
            if df_alt is not None:
                change = ((df_alt.iloc[-1]['close'] - df_alt.iloc[0]['close']) / df_alt.iloc[0]['close']) * 100
                changes.append(change)
        
        if changes:
            avg_alt_change = np.mean(changes)
        
        diff = eth_change - avg_alt_change
        if diff > 1:
            return f"üíé ETH M·∫†NH h∆°n th·ªã tr∆∞·ªùng (+{diff:.2f}%)"
        elif diff < -1:
            return f"üîª ETH Y·∫æU h∆°n th·ªã tr∆∞·ªùng ({diff:.2f}%)"
        else:
            return f"üìä ETH/TRUNG T√çNH ({diff:.2f}%)"
    except Exception as e:
        safe_log(f"‚ùå L·ªói so s√°nh altcoin: {e}")
        return "üìä ETH/Kh√¥ng x√°c ƒë·ªãnh"

def daily_performance_report():
    """G·ª≠i b√°o c√°o hi·ªáu su·∫•t cu·ªëi ng√†y"""
    if len(signal_history) == 0:
        return
    
    total = len(signal_history)
    wins = sum(1 for s in signal_history if s.get('profit', False))
    winrate = (wins / total) * 100 if total > 0 else 0
    avg_pnl = np.mean([s.get('pnl', 0) for s in signal_history]) if signal_history else 0
    
    report = f"""üìä *B√ÅO C√ÅO HI·ªÜU SU·∫§T NG√ÄY*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìà *T·ªïng t√≠n hi·ªáu:* {total}
‚úÖ *T√≠n hi·ªáu th·∫Øng:* {wins}
üìä *T·ª∑ l·ªá th·∫Øng:* {winrate:.1f}%
üí∞ *L·ª£i nhu·∫≠n TB:* {avg_pnl:.2f}%

‚è∞ *Th·ªùi gian:* {datetime.now().strftime("%d/%m/%Y")}
"""
    
    send_telegram_message(report)
    # ==================== üîß H√ÄM PH√ÇN T√çCH CH√çNH ====================

def analyze_signals_advanced(df_15m):
    """Ph√¢n t√≠ch t√≠n hi·ªáu n√¢ng cao v·ªõi t·∫•t c·∫£ c√°c t√≠nh nƒÉng"""
    if df_15m is None or len(df_15m) < 50:
        return 0, 0, []
    
    # T√≠nh c√°c ch·ªâ b√°o
    df_15m['rsi'] = compute_rsi(df_15m['close'])
    macd_line, signal_line = compute_macd(df_15m['close'])
    df_15m['macd'] = macd_line
    df_15m['macd_signal'] = signal_line
    df_15m['ema12'] = df_15m['close'].ewm(span=12).mean()
    df_15m['ema26'] = df_15m['close'].ewm(span=26).mean()
    df_15m['sma50'] = df_15m['close'].rolling(50).mean()
    df_15m['bb_mid'], df_15m['bb_upper'], df_15m['bb_lower'] = compute_bollinger_bands(df_15m['close'])
    df_15m['atr'] = compute_atr(df_15m['high'], df_15m['low'], df_15m['close'])

    current = df_15m.iloc[-1]
    prev = df_15m.iloc[-2]

    buy_score = 0
    sell_score = 0
    signals = []

    # ============ PH√ÇN T√çCH RSI ============
    if current['rsi'] < 25:
        buy_score += 4
        signals.append("üî• RSI c·ª±c Oversold (<25)")
    elif current['rsi'] < 35:
        buy_score += 3
        signals.append("üü¢ RSI th·∫•p (<35)")
    elif current['rsi'] > 75:
        sell_score += 4
        signals.append("üî• RSI c·ª±c Overbought (>75)")
    elif current['rsi'] > 65:
        sell_score += 3
        signals.append("üî¥ RSI cao (>65)")

    # ============ PH√ÇN T√çCH EMA CROSS ============
    ema_cross_up = (prev['ema12'] <= prev['ema26']) and (current['ema12'] > current['ema26'])
    ema_cross_down = (prev['ema12'] >= prev['ema26']) and (current['ema12'] < current['ema26'])

    if ema_cross_up:
        buy_score += 4
        signals.append("üöÄ EMA12 v∆∞·ª£t EMA26")
    elif ema_cross_down:
        sell_score += 4
        signals.append("üí• EMA12 xu·ªëng d∆∞·ªõi EMA26")

    # ============ PH√ÇN T√çCH MACD ============
    macd_cross_up = (prev['macd'] <= prev['macd_signal']) and (current['macd'] > current['macd_signal'])
    macd_cross_down = (prev['macd'] >= prev['macd_signal']) and (current['macd'] < current['macd_signal'])

    if macd_cross_up:
        buy_score += 3
        signals.append("‚¨ÜÔ∏è MACD tƒÉng")
    elif macd_cross_down:
        sell_score += 3
        signals.append("‚¨áÔ∏è MACD gi·∫£m")

    # ============ PH√ÇN T√çCH GI√Å TREND ============
    price_change = ((current['close'] - prev['close']) / prev['close']) * 100
    if abs(price_change) > 1.5:
        if price_change > 0:
            buy_score += 2
            signals.append(f"üìà Gi√° tƒÉng nhanh (+{price_change:.1f}%)")
        else:
            sell_score += 2
            signals.append(f"üìâ Gi√° gi·∫£m nhanh ({price_change:.1f}%)")

    # ============ PH√ÇN T√çCH BOLLINGER BANDS ============
    if current['close'] < current['bb_lower']:
        buy_score += 3
        signals.append("üîµ Gi√° ch·∫°m d·∫£i d∆∞·ªõi Bollinger")
    elif current['close'] > current['bb_upper']:
        sell_score += 3
        signals.append("üîµ Gi√° ch·∫°m d·∫£i tr√™n Bollinger")

    # ============ PH√ÇN T√çCH VOLUME ============
    avg_volume = df_15m['volume'].tail(15).mean()
    current_volume = current['volume']
    if current_volume > avg_volume * 2:
        if buy_score > sell_score:
            buy_score += 2
            signals.append("üí™ Volume b√πng n·ªï")
        else:
            sell_score += 2
            signals.append("üí™ Volume b√πng n·ªï")

    # ============ PH√ÇN T√çCH M√î H√åNH N·∫æN NH·∫¨T ============
    candle_signals = detect_candlestick_patterns(df_15m)
    signals.extend(candle_signals)
    buy_score += len([s for s in candle_signals if "üü¢" in s or "üî®" in s]) * 2
    sell_score += len([s for s in candle_signals if "üî¥" in s or "‚≠ê" in s]) * 2

    # ============ PH√ÇN T√çCH V√ôNG SUPPLY/DEMAND ============
    zones = detect_supply_demand_zones(df_15m)
    signals.extend(zones)
    
    # ============ PH√ÇN T√çCH GIAI ƒêO·∫†N TH·ªä TR∆Ø·ªúNG ============
    market_phase = market_phase_analysis(df_15m)
    signals.append(market_phase)
    
    # ============ PH√ÅT HI·ªÜN T√çN HI·ªÜU GI·∫¢ ============
    if detect_fake_breakout(df_15m):
        signals.append("‚ö†Ô∏è C·∫£nh b√°o: C√≥ th·ªÉ l√† t√≠n hi·ªáu gi·∫£")
        # Gi·∫£m ƒëi·ªÉm ƒë·ªÉ th·∫≠n tr·ªçng
        buy_score = max(0, buy_score - 2)
        sell_score = max(0, sell_score - 2)

    return buy_score, sell_score, signals

def send_analysis_alert():
    """H√†m ch√≠nh ƒë·ªÉ ph√¢n t√≠ch v√† g·ª≠i t√≠n hi·ªáu n√¢ng cao"""
    try:
        safe_log("üîÑ ƒêang ph√¢n t√≠ch t√≠n hi·ªáu n√¢ng cao...")
        
        # 1. L·∫•y d·ªØ li·ªáu 15m
        df_15m = get_klines("ETHUSDT", "15m", 200)
        if df_15m is None or len(df_15m) < 100:
            safe_log("‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu h·ª£p l·ªá")
            return
        
        current_price = df_15m.iloc[-1]['close']
        
        # 2. Ph√¢n t√≠ch t√≠n hi·ªáu n√¢ng cao
        buy_score, sell_score, all_signals = analyze_signals_advanced(df_15m)
        
        # 3. Ph√¢n t√≠ch Funding Rate
        funding_rate = get_funding_rate("ETHUSDT")
        if funding_rate > 0.1:
            all_signals.append(f"üìà Funding Rate cao ({funding_rate:.3f}%) - C·∫©n th·∫≠n ƒë·∫£o chi·ªÅu")
            sell_score += 1
        elif funding_rate < -0.1:
            all_signals.append(f"üìâ Funding Rate th·∫•p ({funding_rate:.3f}%) - C∆° h·ªôi mua")
            buy_score += 1
        
        # 4. Ph√¢n t√≠ch Order Book
        bids, asks = get_orderbook("ETHUSDT", 50)
        ob_signals = analyze_orderbook(bids, asks, current_price)
        all_signals.extend(ob_signals)
        
        # 5. So s√°nh v·ªõi altcoin
        altcoin_status = compare_with_altcoins()
        all_signals.append(altcoin_status)
        if "M·∫†NH" in altcoin_status:
            buy_score += 1
        elif "Y·∫æU" in altcoin_status:
            sell_score += 1
        
        # 6. X√°c ƒë·ªãnh h√†nh ƒë·ªông
        if buy_score >= 8:
            action, action_emoji, strength = "MUA M·∫†NH", "üü¢üî•", "R·∫§T M·∫†NH"
        elif buy_score >= 5:
            action, action_emoji, strength = "MUA", "üü¢", "M·∫†NH"
        elif sell_score >= 8:
            action, action_emoji, strength = "B√ÅN M·∫†NH", "üî¥üî•", "R·∫§T M·∫†NH"
        elif sell_score >= 5:
            action, action_emoji, strength = "B√ÅN", "üî¥", "M·∫†NH"
        elif buy_score > sell_score:
            action, action_emoji, strength = "NGHI√äNG MUA", "üü°", "TRUNG B√åNH"
        elif sell_score > buy_score:
            action, action_emoji, strength = "NGHI√äNG B√ÅN", "üü°", "TRUNG B√åNH"
        else:
            action, action_emoji, strength = "HOLD", "‚ö™", "Y·∫æU"
        
        # 7. T·∫°o danh s√°ch t√≠n hi·ªáu (gi·ªõi h·∫°n 12)
        signal_text = "\n".join([f"‚Ä¢ {s}" for s in all_signals[:12]])
        if len(all_signals) > 12:
            signal_text += f"\n‚Ä¢ ... v√† {len(all_signals) - 12} t√≠n hi·ªáu kh√°c"
        if not signal_text:
            signal_text = "‚Ä¢ Kh√¥ng c√≥ t√≠n hi·ªáu ƒë·∫∑c bi·ªát"
        
        # 8. T·∫°o tin nh·∫Øn
        message = f"""{action_emoji} *T√çN HI·ªÜU {action}* {action_emoji}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
ü™ô *T√†i s·∫£n:* ETH/USDT
üí∞ *Gi√° hi·ªán t·∫°i:* ${current_price:.2f}
üìä *RSI:* {df_15m.iloc[-1]['rsi']:.1f}
üìà *ƒê·ªô m·∫°nh:* {strength}
‚öñÔ∏è *ƒêi·ªÉm MUA:* {buy_score} | *ƒêi·ªÉm B√ÅN:* {sell_score}
üí± *Funding Rate:* {funding_rate:.3f}%

üéØ *C√ÅC T√çN HI·ªÜU:*
{signal_text}

‚è∞ *Th·ªùi gian:* {datetime.now().strftime("%d/%m/%Y %H:%M")}

‚ö†Ô∏è *L∆∞u √Ω:* ƒê√¢y ch·ªâ l√† ph√¢n t√≠ch k·ªπ thu·∫≠t, kh√¥ng ph·∫£i l·ªùi khuy√™n ƒë·∫ßu t∆∞."""

        # 9. G·ª≠i tin nh·∫Øn
        send_telegram_message(message)
        
        # 10. L∆∞u v√†o l·ªãch s·ª≠ ƒë·ªÉ th·ªëng k√™
        signal_record = {
            'time': datetime.now(),
            'action': action,
            'price': current_price,
            'buy_score': buy_score,
            'sell_score': sell_score
        }
        signal_history.append(signal_record)
        performance_stats['total_signals'] += 1
        
    except Exception as e:
        safe_log(f"‚ùå L·ªói t·ªïng qu√°t trong send_analysis_alert: {e}")

# ==================== üîß CH·∫†Y BOT ====================

def main():
    print("üöÄ Bot ETH Trading Super Analyst - 10 T√≠nh nƒÉng n√¢ng cao")
    print("üìã Chat ID:", CHAT_ID)
    print("=" * 60)

    # Test k·∫øt n·ªëi tr∆∞·ªõc
    if not test_telegram_connection():
        print("‚ùå D·ª™NG: Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c Telegram!")
        print("\nüîß H√£y ki·ªÉm tra:")
        print("1. M·ªü Telegram v√† t√¨m bot c·ªßa b·∫°n")
        print("2. G·ª≠i /start cho bot")
        print("3. Ki·ªÉm tra Chat ID c√≥ ƒë√∫ng kh√¥ng")
        return

    # Ch·∫°y test ngay l·∫≠p t·ª©c
    print("\nüß™ Ch·∫°y ph√¢n t√≠ch ƒë·∫ßu ti√™n...")
    send_analysis_alert()

    # L√™n l·ªãch ch·∫°y m·ªói 5 ph√∫t
    schedule.every(5).minutes.do(send_analysis_alert)
    
    # G·ª≠i b√°o c√°o cu·ªëi ng√†y
    schedule.every().day.at("23:55").do(daily_performance_report)

    print("\n‚è∞ Bot ƒë√£ s·∫µn s√†ng! S·∫Ω ph√¢n t√≠ch m·ªói 5 ph√∫t...")
    print("üìä B√°o c√°o hi·ªáu su·∫•t s·∫Ω ƒë∆∞·ª£c g·ª≠i l√∫c 23:55")
    print("üõë Nh·∫•n Ctrl+C ƒë·ªÉ d·ª´ng bot")

    try:
        while True:
            schedule.run_pending()
            time.sleep(30)
    except KeyboardInterrupt:
        print("\nüõë Bot ƒë√£ d·ª´ng!")
        safe_log("Bot stopped by user")

if __name__ == "__main__":
    main()